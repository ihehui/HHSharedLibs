#include "messageloggerbase.h"
#include <QDateTime>
#include <QFileInfo>
#include <QDir>
#include <QProcess>
#include <QCoreApplication>


#if defined(Q_OS_WIN32)
#include <qt_windows.h>
#else
#include <unistd.h>
#include <stdlib.h>

#include <execinfo.h>
#include <signal.h>

#include <cxxabi.h>
#include <memory>
#endif



//////////////////////////////////////////////////////////////////////////

#if defined(Q_OS_LINUX)


void cleanup_ptr()
{
    char cmd[128];
    snprintf(cmd, sizeof(cmd), "sleep 5 && kill -9 %d", getpid());
    popen(cmd, "r");
}


//// Linux Signals: SIGPIPE, SIGSEGV, SIGFPE, SIGABRT
////USAGE:  signal(SIGSEGV, gdbdump); // SIGSEGV 11  Core Invalid memory reference
void gdbdump(int signo)
{
    char buf[1024];
    char cmd[1024];
    FILE *fh;

    snprintf(buf, sizeof(buf), "/proc/%d/cmdline", getpid());
    if(!(fh = fopen(buf, "r"))){
        exit(0);
    }

    if(!fgets(buf, sizeof(buf), fh)){
        exit(0);
    }

    fclose(fh);
    if(buf[strlen(buf) - 1] == '\n'){
        buf[strlen(buf) - 1] = '\0';
    }

    snprintf(cmd, sizeof(cmd), "gdb %s %d -q --batch -ex=bt > ./a.txt", buf, getpid());
    system(cmd);

    exit(signo);
}


//typedef void (*Callback_AfterGdbDump)(int signalNO, const QByteArray &dump);
Callback_AfterGdbDump m_afterGdbDumpFunction = 0;

void QGdbDump(int sigNO)
{

    char buf[1024];
    FILE *fh;

    snprintf(buf, sizeof(buf), "/proc/%d/cmdline", getpid());
    //snprintf(buf, sizeof(buf), "/proc/self/maps");

    if(!(fh = fopen(buf, "r"))){
        exit(0);
    }

    if(!fgets(buf, sizeof(buf), fh)){
        exit(0);
    }

    fclose(fh);
    if(buf[strlen(buf) - 1] == '\n'){
        buf[strlen(buf) - 1] = '\0';
    }

    //char cmd[1024];
    //snprintf(cmd, sizeof(cmd), "gdb %s %d -q --batch -ex=bt > ./a.txt", buf, getpid());
    //system(cmd);

    QStringList dump;
    QProcess process;
    QStringList arguments;
    arguments << buf << QString::number(getpid()) << "-q" << "--batch" << "-ex=bt";
    process.start("gdb",  arguments);
    if(!process.waitForFinished()){
        dump.append("App crashed! Failed to start gdb process!");
    }else{
        dump.append(process.readAll());
    }
    LOGFATAL << "APP CRASHED!";


    //fprintf(stderr, "APP CRASHED!\nCode:%d\nDUMP:\n%s", sigNO, dump.data());
    LOGCRASH << "\n---------------------------------------------"
             << "\nAPP CRASHED!"
             << "\nCode:"<<sigNO
             << "\nDUMP:\n"<<dump.join("\n")
             << "\n---------------------------------------------"
             << "\n";

    //    QFile logFile("./crash.log");
    //    if(logFile.open(QIODevice::WriteOnly | QIODevice::Text)){
    //        logFile.write(dump);
    //        logFile.flush();
    //    }


    if(m_afterGdbDumpFunction){
        m_afterGdbDumpFunction(sigNO, dump);
    }


    //QCoreApplication::exit(sigNO);
    //exit(sigNO);
}


std::string demangle(const char* symbol)
{
    size_t size;
    int status;
    char temp[128];
    char* demangled;
    //first, try to demangle a c++ name
    if (1 == sscanf(symbol, "%*[^(]%*[^_]%127[^)+]", temp)) {
        if (NULL != (demangled = abi::__cxa_demangle(temp, NULL, &size, &status))) {
            std::string result(demangled);
            free(demangled);
            return result;
        }
    }
    //if that didn't work, try to get a regular c symbol
    if (1 == sscanf(symbol, "%127s", temp)) {
        return temp;
    }

    //if all else fails, just return the symbol
    return symbol;
}


// The prefix used for mangled symbols, per the Itanium C++ ABI:
// http://www.codesourcery.com/cxx-abi/abi.html#mangling
const char kMangledSymbolPrefix[] = "_Z";
// Characters that can be used for symbols, generated by Ruby:
// (('a'..'z').to_a+('A'..'Z').to_a+('0'..'9').to_a + ['_']).join
const char kSymbolCharacters[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_";
// Demangles C++ symbols in the given text. Example:
// "out/Debug/base_unittests(_ZN10StackTraceC1Ev+0x20) [0x817778c]"
// =>
// "out/Debug/base_unittests(StackTrace::StackTrace()+0x20) [0x817778c]"
void DemangleSymbol (std::string* symbol)
{
    std::string::size_type search_from = 0;
    while (search_from < symbol->size ()) {
        // Look for the start of a mangled symbol from search_from
        std::string::size_type mangled_start = symbol->find (kMangledSymbolPrefix, search_from);
        if (mangled_start == std::string::npos) {
            break; // Mangled symbol not found
        }
        // Look for the end of the mangled symbol
        std::string::size_type mangled_end = symbol->find_first_not_of (kSymbolCharacters, mangled_start);
        if (mangled_end == std::string::npos) {
            mangled_end = symbol->size ();
        }
        std::string mangled_symbol = std::move (symbol->substr (mangled_start, mangled_end - mangled_start));
        // Try to demangle the mangled symbol candidate
        int status = -4; // some arbitrary value to eliminate the compiler warning
        std::unique_ptr<char, void(*)(void*)> demangled_symbol {
            abi::__cxa_demangle (mangled_symbol.c_str (), nullptr, 0, &status),
                    std::free
        };
        // 0 Demangling is success
        if (0 == status) {
            // Remove the mangled symbol
            symbol->erase (mangled_start, mangled_end - mangled_start);
            // Insert the demangled symbol
            symbol->insert (mangled_start, demangled_symbol.get ());
            // Next time, we will start right after the demangled symbol
            search_from = mangled_start + strlen (demangled_symbol.get ());
        }
        else {
            // Failed to demangle. Retry after the "_Z" we just found
            search_from = mangled_start + 2;
        }
    }
}





///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////                     USAGE:
////      void afterCrashDump(int signalNO, const QStringList &dump)
////       {
////           .....
////           .....
////       }
////
////
////     Add the following lines to main() function:
////      #if defined(Q_OS_LINUX)
////        enableCrashHandler(afterCrashDump);
////      #endif
////
////


QString addr2line(const QStringList &dump)
{
    QStringList results;
    QString msg;
    for(int i=0; i<dump.size(); i++){
        msg = dump.at(i);
        if(!msg.contains(") [0")){
            continue;
        }
        msg = msg.split(") [").at(1);
        msg.remove("]");
        results.append(msg);
    }

    QString processName = "addr2line";
    QStringList args;
    args <<QString("-Cspfe")<<QCoreApplication::applicationFilePath();
    QProcess process;
    QString output;
    for(int i=0; i<results.size(); i++){
        process.start(processName, args, QIODevice::ReadWrite);
        if(process.waitForStarted()){
            process.write(results[i].toLatin1());
            process.closeWriteChannel();
        }
        if(process.waitForReadyRead()){
            output = QString(process.readAllStandardOutput()).simplified();
            //if(!output.trimmed().isEmpty()){
            results[i] = "[" + results[i] + "] " + output;
            //}
        }
        process.close();
    }

    return results.join("\n");
}

////
////USAGE:  signal(SIGSEGV, signalHandler);
///  addr2line 0x08048258 -e a.o -f -C
static void signalHandler(int sigNO)
{
    void *array[10];
    size_t size;
    char **strings;

    signal(sigNO, SIG_DFL); /* 还原默认的信号处理handler */

    size = backtrace (array, 10);
    strings = (char **)backtrace_symbols (array, size);

    QStringList dump;
    //fprintf(stderr, "Received SIGSEGV! Stack trace:\n");
    for (size_t i = 0; i < size; i++) {

        //        // M1:
        //        fprintf(stderr, "%d %s \n",i, strings[i]);

        //        // M2:
        //        fprintf(stderr, "%d %s \n",i, demangle(strings[i]).c_str());

        //        // M3:
        //        std::string str(strings[i]);
        //        DemangleSymbol(&str);
        //        fprintf(stderr, "%d %s \n",i, str.c_str());


        dump.append(QString(strings[i]));

    }
    free (strings);


    LOGFATAL << "APP CRASHED!";
    //fprintf(stderr, "APP CRASHED!\nCode:%d\nDUMP:\n%s", sigNO, dump.data());

//    LOGCRASH << "\n---------------------------------------------"
//             << "\nAPP CRASHED!"
//             << "Time:"<<QDateTime::currentDateTime().toString("yyyy-MM-dd hhLmm:ss")
//             << "\nCode:"<<sigNO
//             << QString("\nDUMP:\n%1").arg(dump.join("\n"))
//             << "\n---------------------------------------------\n"
//             << "\n---------------------------------------------\n"
//             << QString("%1").arg(addr2line(dump))
//             << "\n---------------------------------------------"
//             << "\n";

    QString msg = "\n---------------------------------------------";
    msg += "\nAPP CRASHED!";
    msg += "\nTime:" + QDateTime::currentDateTime().toString("yyyy-MM-dd hhLmm:ss");
    msg += "\nCode:" + sigNO;
    msg += "\nDUMP:\n" + dump.join("\n");
    msg += "\n---------------------------------------------\n";
    msg += "\n---------------------------------------------\n";
    msg += addr2line(dump);
    msg += "\n---------------------------------------------\n";
    LOGCRASH << msg;


    if(m_afterGdbDumpFunction){
        m_afterGdbDumpFunction(sigNO, dump);
    }


    //exit(sigNO);
}

///////////////////////////////////////////////////////////////////////////////

void enableCrashHandler(Callback_AfterGdbDump handler)
{
    m_afterGdbDumpFunction = handler;

    //    signal(SIGPIPE, QGdbDump);
    //    signal(SIGSEGV, QGdbDump);
    //    signal(SIGFPE, QGdbDump);
    //    signal(SIGABRT, QGdbDump);
    //    signal(SIGSTKFLT, QGdbDump);

    signal(SIGPIPE, signalHandler);
    signal(SIGSEGV, signalHandler);
    signal(SIGFPE, signalHandler);
    signal(SIGABRT, signalHandler);
    signal(SIGSTKFLT, signalHandler);
    signal(SIGBUS, signalHandler);

}


#endif

//////////////////////////////////////////////////////////////////////////





//////////////////////////////////////////////////////////////////////////
#if QT_VERSION >= 0x050000
void logQtDebug(QtMsgType type, const QMessageLogContext &context, const QString &msg)
#else
void logQtDebug(QtMsgType type, const char* msg)
#endif
{
    static QMutex mutex;
    QMutexLocker locker(&mutex);

    QString fileName = "";
    QString funtionName = "";
    int lineNumber = 0;

#if QT_VERSION >= 0x050000
    fileName = context.file;
    funtionName = context.function;
    lineNumber = context.line;
#endif

    MsgType logType = MSG_DEBUG;

    switch (type) {
    case QtWarningMsg:
        logType = MSG_WARNING;
        break;

    case QtCriticalMsg:
        logType = MSG_CRITICAL;
        break;

    case QtFatalMsg:
        logType = MSG_FATAL;
        break;

    case QtDebugMsg:
        logType = MSG_DEBUG;
        break;

        //    case QtInfoMsg:
        //        logType = MSG_INFO;
        //        break;

    default:
        logType = MSG_INFO;
        break;
    }

    switch (logType) {
    case MSG_WARNING:
        LogQtWarningMessage(fileName, funtionName, lineNumber, logType) << msg;
        break;

    case MSG_CRITICAL:
    case MSG_FATAL:
        LogMessage(fileName, funtionName, lineNumber, logType) << msg;
        break;

    case MSG_DEBUG:
        LogQtDebugMessage(fileName, funtionName, lineNumber, logType) << msg;
        break;

    default:
        LogQtInfoMessage(fileName, funtionName, lineNumber, logType) << msg;

        break;
    }

    //LogQtMessage(fileName, funtionName, lineNumber, logType) << msg;

    //    if (type == QtFatalMsg) {
    //        exit(1);
    //    }
}

void installQtMessageLogger(){

#  if QT_VERSION >= 0x050000
    //reset the message handler
    qInstallMessageHandler(0);
    qInstallMessageHandler(logQtDebug);
#  else
    qInstallMsgHandler(0);
    qInstallMsgHandler(logQtDebug);
#  endif

    //qAddPostRoutine(closeDebugLog);

}

void uninstallQtMessageLogger(){
    //reset the message handler
#  if QT_VERSION >= 0x050000
    qInstallMessageHandler(0);
#  else
    qInstallMsgHandler(0);
#  endif

}
//////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////
MessageLoggerBase * LogMessage::m_messageLoggerBase = 0;

LogMessage::LogMessage(const QString &fileName, const QString &funtionName, int lineNumber, MsgType type)
{

    m_messageStruct = new MessageStruct();
    m_messageStruct->threadId = QString::number((quint64)QThread::currentThreadId());
    m_messageStruct->time = QDateTime::currentDateTime();
    m_messageStruct->logType = type;

    m_messageStruct->fileName = fileName;
    m_messageStruct->fileName = m_messageStruct->fileName.replace("\\", "/");
    m_messageStruct->fileName = m_messageStruct->fileName.remove(0, m_messageStruct->fileName.lastIndexOf("/") + 1);

    m_messageStruct->funtionName = funtionName;
    m_messageStruct->lineNumber = lineNumber;

}

LogMessage::LogMessage(const LogMessage &other)
{

    if (this != &other) {


        //        this->m_messageStruct->threadId = other.m_messageStruct->threadId;
        //        this->m_messageStruct->time = other.m_messageStruct->time;
        //        this->m_messageStruct->logType = other.m_messageStruct->logType;
        //        this->m_messageStruct->messages = other.m_messageStruct->messages;
        //        this->m_messageStruct->fileName = other.m_messageStruct->fileName;
        //        this->m_messageStruct->funtionName = other.m_messageStruct->funtionName;
        //        this->m_messageStruct->lineNumber = other.m_messageStruct->lineNumber;
        //        this->m_messageStruct->ref = other.m_messageStruct->ref;

        m_messageStruct = other.m_messageStruct;
        m_messageStruct->ref++;
    }
}

LogMessage &LogMessage::operator=(const LogMessage &other)
{

    if (this != &other) {
        //        this->m_messageStruct->threadId = other.m_messageStruct->threadId;
        //        this->m_messageStruct->time = other.m_messageStruct->time;
        //        this->m_messageStruct->logType = other.m_messageStruct->logType;
        //        this->m_messageStruct->messages = other.m_messageStruct->messages;
        //        this->m_messageStruct->fileName = other.m_messageStruct->fileName;
        //        this->m_messageStruct->funtionName = other.m_messageStruct->funtionName;
        //        this->m_messageStruct->lineNumber = other.m_messageStruct->lineNumber;
        //        this->m_messageStruct->ref = other.m_messageStruct->ref;

        m_messageStruct = other.m_messageStruct;
        m_messageStruct->ref++;

    }

    return *this;
}

LogMessage::~LogMessage()
{
    (m_messageStruct->ref)--;
    if(!(m_messageStruct->ref)){
        if(m_messageLoggerBase){
            m_messageLoggerBase->appendMessage(m_messageStruct);
        }
    }

}

LogMessage & LogMessage::operator<< (const long &value)
{
    m_messageStruct->messages += (QString::number(value));
    return *this;
}

LogMessage & LogMessage::operator<< (const QVariant &variant){
    if(variant.canConvert(QVariant::String)){
        m_messageStruct->messages += (variant.toString());
    }
    return *this;
}

void LogMessage::setMessageLoggerBase(MessageLoggerBase *messageLoggerBase)
{
    m_messageLoggerBase = messageLoggerBase;
}
//////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////

#if defined(Q_OS_WIN32)
qulonglong MessageLoggerBase::m_processId = GetCurrentProcessId();
#else
qulonglong MessageLoggerBase::m_processId = getpid();
#endif

MessageLoggerBase::MessageLoggerBase(QObject *parent)
    :QThread(parent)
{
    m_outputTarget = MessageLoggerBase::TARGET_FILE;
    m_logTypesForFile = MSG_IMPORTANT;
    m_logTypesForDatabase = MSG_IMPORTANT;
    m_logTypesForConsole = MSG_ANY;

    m_quit = false;
    m_wokeUp = false;
    m_logQtMessages = false;
    m_threadFinished = true;


    m_messageTypeToString.insert(MSG_WARNING, " WARNING");
    m_messageTypeToString.insert(MSG_CRITICAL, "CRITICAL");
    m_messageTypeToString.insert(MSG_FATAL, "   FATAL");
    m_messageTypeToString.insert(MSG_CRASH, "   CRASH");
    m_messageTypeToString.insert(MSG_INFO, "    INFO");
    m_messageTypeToString.insert(MSG_DEBUG, "   DEBUG");

    m_appVersion = "0.0.1";

}

MessageLoggerBase::~MessageLoggerBase()
{
    //    if(m_logQtMessages){
    //        uninstallQtMessageLogger();
    //    }

    //    m_quit = true;
    //    cond.wakeOne();
    //    wait();

    if(!m_quit){
        stopLogger();
    }

}

void MessageLoggerBase::stopLogger()
{
    if(m_logQtMessages){
        uninstallQtMessageLogger();
    }

    {
        QMutexLocker locker(&mutex);
        m_quit = true;
    }
    cond.wakeOne();

    while (!isThreadFinished()) {
        //fprintf(stderr, "Waiting...\n");
    }

}

//The targets is a OR'ed combination of OutputTarget
void MessageLoggerBase::setOutputTargets(quint8 targets)
{
    m_outputTarget = targets;
}

void MessageLoggerBase::setOutputTypes(quint8 typesForFile, quint8 typesForDatabase, quint8 typesForConsole)
{
    m_logTypesForFile = typesForFile;
    m_logTypesForDatabase = typesForDatabase;
    m_logTypesForConsole = typesForConsole;
}

void MessageLoggerBase::setFileConfig(FileConfigStruct fileConfig)
{
    m_fileConfigStruct = fileConfig;
}

void MessageLoggerBase::appendMessage(MessageStruct *messageStruct)
{
    QMutexLocker locker(&mutex);
    m_messageList.append(messageStruct);
    cond.wakeOne();

    //    if (!m_wokeUp) {
    //        m_wokeUp = true;
    //        QMetaObject::invokeMethod(this, "wakeUp", Qt::QueuedConnection);
    //    }

}

quint8 MessageLoggerBase::getOutputTarget()
{
    return m_outputTarget;
}

bool MessageLoggerBase::isOutputToDatabase()
{
    return (m_outputTarget & TARGET_DATABASE);
}

void MessageLoggerBase::setLogQtMessagesEnabled(bool enabled)
{
    m_logQtMessages = enabled;
    if(enabled){
        installQtMessageLogger();
    }else{
        uninstallQtMessageLogger();
    }
}

bool MessageLoggerBase::isloggingQtMessages() const
{
    return m_logQtMessages;
}

void MessageLoggerBase::setAppVersion(const QString &appVersion)
{
    m_appVersion = appVersion;
}

void MessageLoggerBase::run()
{
    //fprintf(stderr, "Message Logger Thread Started");

    setThreadFinished(false);

    do {

        {
            // Go to sleep if there's nothing to do.
            QMutexLocker locker(&mutex);
            if (!m_quit && m_messageList.isEmpty())
            {
                cond.wait(&mutex);
            }
        }

        // Write pending messages
        mutex.lock();
        QList<MessageStruct *> messageList = m_messageList;
        m_messageList.clear();
        mutex.unlock();

        beginOutputMessage();
        while (!messageList.isEmpty()) {
            MessageStruct *msgStruct = messageList.takeFirst();
            outputMessage(msgStruct);
            delete msgStruct;
        }
        endOutputMessage();


    } while (!m_quit);

    // Write pending messages
    mutex.lock();
    QList<MessageStruct *> messageList = m_messageList;
    m_messageList.clear();
    mutex.unlock();

    beginOutputMessage();
    while (!messageList.isEmpty()) {
        MessageStruct *msgStruct = messageList.takeFirst();
        outputMessage(msgStruct);
        delete msgStruct;
    }
    endOutputMessage();

    //Close File
    if(m_outputTarget & TARGET_FILE){
        closeFile();
    }

    if(m_outputTarget & TARGET_DATABASE){
        closeDatabase();
    }

    setThreadFinished(true);

    //fprintf(stderr, "Message Logger Thread Finished");


}

void MessageLoggerBase::wakeUp()
{
    QMutexLocker locker(&mutex);
    m_wokeUp = false;
    cond.wakeOne();
}

bool MessageLoggerBase::beginOutputMessage()
{
    return true;
}

void MessageLoggerBase::outputMessage(MessageStruct *messageStruct)
{

    if( (m_outputTarget & TARGET_CONSOLE) && (m_logTypesForConsole & messageStruct->logType) ){
        QString typeString = m_messageTypeToString[messageStruct->logType];
        QString functionInfo = "";
        if(!messageStruct->fileName.trimmed().isEmpty()){
            functionInfo = QString("%1:%2, %3.").arg(messageStruct->fileName).arg(messageStruct->lineNumber).arg(messageStruct->funtionName);
            functionInfo = functionInfo.replace("\\", "/");
            functionInfo = functionInfo.remove(0, functionInfo.lastIndexOf("/") + 1);
        }

        //QString str = QString("%1[%2] %3 %4 (%5)").arg(messageStruct->time.toString("yyyy-MM-dd hh:mm:ss:zzz")).arg(messageStruct->threadId).arg(typeString).arg(messageStruct->messages.join("")).arg(functionInfo);
        QString str = QString("[%1] [%2] [%3] [%4] [%5]").arg(messageStruct->time.toString("hh:mm:ss:zzz")).arg(messageStruct->threadId).arg(typeString).arg(messageStruct->messages).arg(functionInfo);
        fprintf(stderr, "%s\n", str.toUtf8().data());
    }

    if( (m_outputTarget & TARGET_FILE) && (m_logTypesForFile & messageStruct->logType) ){
        saveToFile(messageStruct);
    }

    if( (m_outputTarget & TARGET_DATABASE) && (m_logTypesForDatabase & messageStruct->logType)){
        saveToDatabase(messageStruct);
    }

}

bool MessageLoggerBase::endOutputMessage()
{
    return true;
}

bool MessageLoggerBase::saveToFile(MessageStruct *messageStruct)
{
    QDateTime time = QDateTime::currentDateTime();
    QString logFileName = m_fileConfigStruct.baseDir + time.toString(m_fileConfigStruct.dirTimeTemplate) + "/" + m_fileConfigStruct.fileBaseName + time.toString(m_fileConfigStruct.fileNameTimeTemplate) + "." + m_fileConfigStruct.fileSuffix;
    if(messageStruct->logType == MSG_CRASH){
        logFileName = m_fileConfigStruct.baseDir + time.toString(m_fileConfigStruct.dirTimeTemplate) + "/" + m_fileConfigStruct.fileBaseName + time.toString("yyyyMMddhhmmss") + ".crash";
    }

    QFile *file = m_fileConfigStruct.file;
    if(file && file->fileName() != logFileName){
        closeFile();
        file = 0;
    }

    if(!file){
        QFileInfo info(logFileName);
        QDir dir;
        dir.mkpath(info.path());

        file = new QFile(logFileName);
        if (!file->open(QIODevice::ReadWrite | QIODevice::Text | QIODevice::Append)) {
            qCritical()<<QString("ERROR! Failed to open log file '%1'. %2").arg(logFileName).arg(file->errorString());
            delete file;
            file = 0;
            return false;
        }
        m_fileConfigStruct.file = file;

        //        qulonglong processId = 0;
        //    #if defined(Q_OS_WIN32)
        //        processId = GetCurrentProcessId();
        //    #else
        //        processId = getpid();
        //    #endif

        QString header;
        header += QString(" [V%1] ").arg(m_appVersion);
        header += time.toString("[yyyy-MM-dd hh:mm:ss.zzz]").toLatin1();
        header += " [PID:";
        header += QByteArray::number(m_processId);
        header += "]";
        QString ba("\n-------------------- DEBUG LOG OPENED "+ header + " --------------------\n");
        file->write(ba.toUtf8());
    }

    if(m_fileConfigStruct.truncateFile){
        if(file->size() > m_fileConfigStruct.maxFileSize){
            file->seek(0);
            const qint64 bufSize = (qint64)(file->size() - m_fileConfigStruct.maxFileSize * 0.95);

//            qint64 sizeRead = 0;
//            char buf[1024];
//            qint64 lineLength = 0;
//            while (sizeRead < bufSize) {
//                lineLength = file->readLine(buf, sizeof(buf));
//                if(lineLength < 0){break;}
//                sizeRead += lineLength;
//            }

            file->seek(bufSize);
            file->readLine(1024);

            QByteArray oldData = file->readAll();
            file->resize(0);
            file->write(oldData);
            file->flush();
        }
    }

    QString typeString = m_messageTypeToString[messageStruct->logType];
    QString functionInfo = "";
    if(!messageStruct->fileName.trimmed().isEmpty()){
        functionInfo = QString("%1:%2, %3").arg(messageStruct->fileName).arg(messageStruct->lineNumber).arg(messageStruct->funtionName);
    }

    //QString functionInfo = QString("%1:%2, %3").arg(messageStruct->fileName).arg(messageStruct->lineNumber).arg(messageStruct->funtionName);
    //functionInfo = functionInfo.replace("\\", "/");
    //functionInfo = functionInfo.remove(0, functionInfo.lastIndexOf("/") + 1);
    QString str = QString("[%1] [%2] [%3] [%4] [%5]").arg(messageStruct->time.toString("hh:mm:ss.zzz")).arg(messageStruct->threadId).arg(typeString).arg(messageStruct->messages).arg(functionInfo);
    if(messageStruct->logType == MSG_CRASH){
        str = messageStruct->messages;
    }
    QString ba;
    ba += str;
    ba += '\n';
    file->write(ba.toUtf8());
    file->flush();

    return true;
}

bool MessageLoggerBase::closeFile()
{
    QFile *file = m_fileConfigStruct.file;
    if (!file){return false;}

    //    qulonglong processId = 0;
    //#if defined(Q_OS_WIN32)
    //    processId = GetCurrentProcessId();
    //#else
    //    processId = getpid();
    //#endif

    QString end;
    end += QString(" [V%1] ").arg(m_appVersion);
    end += QDateTime::currentDateTime().toString("[yyyy-MM-dd hh:mm:ss.zzz]").toLatin1();
    end += " [PID:";
    end += QByteArray::number(m_processId);
    end += "] ";
    QString ba("-------------------- DEBUG LOG CLOSED "+ end + " --------------------\n\n");
    file->write(ba.toUtf8());

    file->flush();
    file->close();
    delete file;
    file = 0;

    m_fileConfigStruct.file = 0;

    return true;
}

bool MessageLoggerBase::saveToDatabase(MessageStruct *messageStruct)
{
    Q_UNUSED(messageStruct);

    return true;
}

void MessageLoggerBase::closeDatabase()
{

}

void MessageLoggerBase::setThreadFinished(bool finished)
{
    QMutexLocker locker(&mutex);
    m_threadFinished = finished;
}

bool MessageLoggerBase::isThreadFinished()
{
    QMutexLocker locker(&mutex);
    return m_threadFinished;
}

//////////////////////////////////////////////////////////////////////////






